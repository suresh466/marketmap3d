# GLOBAL CONTEXT: Settings that apply to ALL server blocks
# don't send the nginx version number in error pages and Server header
server_tokens off;

# --- MIME Types Configuration ---
# include /etc/nginx/mime.types; nginx includes this by default, keep it for educational purposes
# Add custom MIME types for files Nginx doesn't recognize by default
types {
    application/geo+json geojson;
    application/manifest+json webmanifest;
}

# --- Rate Limiting Configuration ---
# This creates a "memory zone" that tracks request rates per IP address, think of it as a ledger: "Who made requests and when?"
limit_req_zone $binary_remote_addr zone=general_limit:10m rate=10r/s;
# BREAKDOWN:
# - $binary_remote_addr: The visitor's IP in binary format (more memory efficient)
# - zone=general_limit:10m: Creates a 10MB memory zone called "general_limit"
#   (10MB can track ~160,000 unique IP addresses)
# - rate=10r/s: Allow 10 requests per second per IP

# --- Compression Configuration ---
# Reduces file sizes before sending to browsers (faster page loads, less bandwidth)
gzip on; # Enable compression
gzip_disable "msie6"; # Disable for IE6 (it has bugs with compression)
gzip_comp_level 5; # Compression level 1-9 (5 is a sweet spot: good compression, not too CPU-intensive)
gzip_min_length 256; # Only compress files larger than 256 bytes (tiny files aren't worth compressing)
gzip_proxied any; # Compress responses even if they came from a proxy/upstream server
gzip_vary on; # Add "Vary: Accept-Encoding" header (tells caches to store compressed & uncompressed versions separately)
gzip_types # Which file types to compress (don't list text/html - it's always compressed)
application/javascript
application/json
application/xml
text/javascript
text/css
text/plain
text/xml;

# HTTP SERVER: Port 80 (Insecure) - REDIRECT TO HTTPS
server {
    listen 80;
    server_name marketmap.club www.marketmap.club;

    # Certbot needs HTTP access to verify you own the domain, this MUST be accessible on port 80 (before the HTTPS redirect)
    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
        add_header Cache-Control "no-cache, no-store, must-revalidate" always; # Certbot tmp files here no caching
    }

    # Redirect all HTTP requests to HTTPS
    location / {
        return 301 https://$host$request_uri;
    }
}

# HTTPS SERVER: Port 443 (Secure) - MAIN APPLICATION
server {
    listen 443 ssl;
    http2 on;
    server_name marketmap.club www.marketmap.club;

    root /usr/share/nginx/html; # Where your React build files live
    index index.html; # Default file to serve

    access_log /var/log/nginx/access.log main buffer=16k flush=10s;
    error_log /var/log/nginx/error.log warn; # Only log warnings and errors (not every little thing)

    # --- SSL Certificate Configuration ---
    ssl_certificate /etc/letsencrypt/live/marketmap.club/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/marketmap.club/privkey.pem;
    # These files are created by Certbot

    # --- SSL Security Settings ---
    ssl_protocols TLSv1.2 TLSv1.3; # Only allow modern, secure protocols (no SSLv3, TLSv1.0, TLSv1.1 - they're broken)
    ssl_prefer_server_ciphers on; # Server chooses the cipher (more secure)
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
    # Supported encryption algorithms (prioritizes "forward secrecy" ciphers)

    # --- SSL Session Optimization ---
    ssl_session_cache shared:SSL:10m; # Cache SSL sessions for 10MB (speeds up reconnections)
    ssl_session_timeout 1d; # Keep cached sessions for 1 day
    ssl_session_tickets off; # Disable session tickets (better security, prevents certain attacks)


    # Same as HTTP version - needed for renewals
    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
        add_header Cache-Control "no-cache, no-store, must-revalidate" always;
    }

    # --- Static Assets: Hashed Files (Long-term Cache) ---
    # Files with content hashes in their name (e.g., main.a3f2b9.js), React's build process (npm run build) creates these automatically
    location ~* \.(js|css)$ {
        include /etc/nginx/snippets/security-headers.conf;
        add_header Cache-Control "public, immutable, max-age=31536000" always;
        # Cache for 1 year - safe because filename changes when content changes because of hashing
        # immutable = "Don't even check for updates" (perfect for hashed files)
        limit_req zone=general_limit burst=20 nodelay;
        # Apply rate limiting
    }

    # GeoJSON (updated occasionally)
    location ~* \.geojson$ {
        include /etc/nginx/snippets/security-headers.conf;
        add_header Cache-Control "public, max-age=3600" always;
        add_header Content-Type "application/geo+json" always;
        limit_req zone=general_limit burst=20 nodelay;
    }

    # --- Static Assets: Images & Fonts (Medium-term Cache) ---
    # These change less frequently but don't always have hashed filenames
    location ~* \.(png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot|webp|avif)$ {
        include /etc/nginx/snippets/security-headers.conf;
        add_header Cache-Control "public, max-age=2592000" always;
        # No immutable - allows revalidation if you update images
        limit_req zone=general_limit burst=20 nodelay;
        # Apply rate limiting
    }

    # --- HTML Files (Always Fresh) ---
    # Your main index.html - this should always be fresh
    # so users get the latest version immediately
    location ~* \.html$ {
        include /etc/nginx/snippets/security-headers.conf;
        add_header Cache-Control "no-cache" always;
        # Browser revalidates when online, uses cache when offline
        limit_req zone=general_limit burst=20 nodelay;
        # Apply rate limiting
    }

    # --- React Application (SPA Routing) ---
    # This MUST come last (it's a catch-all)
    location / {
        # SPA Magic: Try to serve the file, if not found, serve index.html
        try_files $uri $uri/ /index.html;
        # EXAMPLE: User visits /about
        # 1. Try /about (file doesn't exist)
        # 2. Try /about/ (directory doesn't exist)
        # 3. Serve /index.html (fallback to index.html)

        # Apply rate limiting
        limit_req zone=general_limit burst=20 nodelay;
        # - burst=20: Allow bursts of up to 20 requests (above the 10r/s rate)
        # - nodelay: Don't make fast users wait if they're within burst limit

    }
}
